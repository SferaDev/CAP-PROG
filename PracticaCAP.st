Object subclass: #PROG	instanceVariableNames: 'finalDestination entryPoint'	classVariableNames: ''	poolDictionaries: ''	category: 'PracticaCAP'!!PROG commentStamp: 'AlexisRico 1/19/2019 21:30' prior: 0!PROG!!PROG methodsFor: 'main' stamp: 'AlexisRico 1/19/2019 19:02'!withInit: initBlock do: instructionSet	"If we have local variables left, store them as bindings"	initBlock isEmpty ifFalse: [		^ self class storeLocalVariable: initBlock in: [			self withInit: initBlock do: instructionSet.		].	].	"If we have instructions left, store them as bindings"	instructionSet isEmpty ifFalse: [		^ self class storeInstruction: instructionSet in: [			self withInit: initBlock do: instructionSet		].	].	"Store return point and start execution with first instruction"	^ self class storeBinding: #RETURN with: finalDestination in: [ entryPoint binding value ].! !!PROG methodsFor: 'initialization' stamp: 'AlexisRico 1/16/2019 14:37'!initializeWith: aContinuation and: aSymbol	finalDestination := aContinuation.	entryPoint := aSymbol.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PROG class	instanceVariableNames: ''!!PROG class methodsFor: 'public' stamp: 'AlexisRico 1/20/2019 16:58'!withInit: initBlock do: instructionSet	instructionSet isEmpty ifTrue: [ Error signal: 'Empty Instruction Set' ].	"Create the default return point as a continuation"	^ Continuation callcc: [ :kont |		| instance |		instance := self new.		"Initialize instance with aContinuation to return and aSymbol to start"		instance initializeWith: kont and: ((instructionSet at: 1) at: 1).		"Launch recursive execution"		instance withInit: (initBlock asOrderedCollection) do: (instructionSet asOrderedCollection).	].! !!PROG class methodsFor: 'binding' stamp: 'AlexisRico 1/20/2019 23:06'!storeLocalVariable: initBlock in: aBlock	| param |	param := initBlock remove: (initBlock at: 1).	param isArray ifTrue: [		^ self storeBinding: (param at: 1) with: (param at: 2) in: aBlock	].	^ self storeBinding: param with: nil in: aBlock.! !!PROG class methodsFor: 'binding' stamp: 'AlexisRico 1/19/2019 18:35'!storeBinding: aSymbol with: aValue in: aBlock	aSymbol bindTo: aValue in: aBlock.! !!PROG class methodsFor: 'binding' stamp: 'AlexisRico 1/20/2019 23:06'!storeInstruction: instructionSet in: aBlock	| instruction nextSymbol |	instruction := instructionSet remove: (instructionSet at: 1).	nextSymbol := instructionSet isEmpty		ifTrue: [ #RETURN ]		ifFalse: [ (instructionSet at: 1) at: 1 ].	^ self storeBinding: (instruction at: 1) with: [		(instruction at: 2) value.		nextSymbol binding value	] in: aBlock! !TestCase subclass: #PROGTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PracticaCAP'!!PROGTest methodsFor: 'general' stamp: 'AlexisRico 1/19/2019 00:08'!testCaseUndefinedSymbol	self should: [		PROG withInit: { "Empty parameters" } do: {			{ #label1 . [ #label2 binding value ] } .			{ #label3 . [ #RETURN binding value ] } .		}.	] raise: Error. "No binding for label2"! !!PROGTest methodsFor: 'general' stamp: 'AlexisRico 1/19/2019 19:26'!testCaseJumping	| result |	result := PROG withInit: { { #n . 0 } } do: {		{#label1 . [ #label3 binding value ] } .		{#label2 . [ #n changeBinding: 1 ] } .		{#label3 . [ #RETURN binding value: #n binding ] } .	}.	self assert: result == 0.! !!PROGTest methodsFor: 'general' stamp: 'AlexisRico 1/19/2019 19:20'!testCaseDefaultReturn2	| result |	result := PROG withInit: { "Empty variables" } do: {		{ #label . [ "Empty block" ] } .	}.	self assert: result isNil.! !!PROGTest methodsFor: 'general' stamp: 'AlexisRico 1/19/2019 18:31'!testCaseBinding2    self should: [        #binding changeBinding: 10.    ] raise: Error. "No binding for binding"! !!PROGTest methodsFor: 'general' stamp: 'AlexisRico 1/19/2019 19:15'!testCaseContinuation	| result kont |	result := PROG withInit: { "Empty variables" } do: {		{ #label1 . [ kont := Continuation callcc: [ :cc | cc ] ] } .		{ #label2 . [ (kont == 10) ifFalse: [ kont value: 10 ] ] } .		{ #label3 . [ #RETURN binding value: kont ] } .	}.	self assert: result == 10.! !!PROGTest methodsFor: 'general' stamp: 'AlexisRico 1/19/2019 19:25'!testCaseInnerBlockReturn	| result capturedVariable |	capturedVariable := 0.	result := PROG withInit: { "Empty variables" } do: {		{ #label1 . [ capturedVariable := [ capturedVariable := 5. #RETURN binding value: 1 ] ] } .		{ #label2 . [ capturedVariable value ] } .		{ #label3 . [ #RETURN binding value: 2 ] } .	}.	self assert: capturedVariable == 5.	self assert: result == 1.! !!PROGTest methodsFor: 'general' stamp: 'AlexisRico 1/19/2019 19:21'!testCaseEarlyReturn	| result capturedVariable |	capturedVariable := 0.	result := PROG withInit: { "Empty variables" } do: {		{ #label1 . [ #RETURN binding value: 1 ] } .		{ #label2 . [ capturedVariable := 5 ] } .		{ #label3 . [ #RETURN binding value: 2 ] } .	}.	self assert: capturedVariable == 0.	self assert: result == 1.! !!PROGTest methodsFor: 'general' stamp: 'AlexisRico 1/19/2019 19:19'!testCaseDefaultReturn1	| result |	result := PROG withInit: { "Empty variables" } do: {		{ #label . [ #RETURN binding value ] } .	}.	self assert: result isNil.! !!PROGTest methodsFor: 'general' stamp: 'AlexisRico 1/19/2019 12:57'!testCaseEmptyInstructions	self should: [		PROG withInit: { "Empty parameters" } do: { "Empty instructions" }.	] raise: Error.! !!PROGTest methodsFor: 'general' stamp: 'AlexisRico 1/19/2019 18:31'!testCaseBinding1	#n bindTo: 1 in: [ 		#n changeBinding: 10.		self assert: #n binding == 10.	] .! !!PROGTest methodsFor: 'general' stamp: 'AlexisRico 1/19/2019 19:14'!testCaseCapturedVariables	| result capturedVariable |	capturedVariable := 0.	result := PROG withInit: { { #n . 0 } } do: {		{ #label1 . [ capturedVariable := 5 ] } .		{ #label2 . [ #RETURN binding value: capturedVariable ] } .	}.	self assert: result == 5.! !!PROGTest methodsFor: 'default' stamp: 'AlexisRico 1/18/2019 23:38'!testCaseBase1	| result |		result := PROG withInit: { #n . { #d . 0 } } do: {		{ #label1 . [ #n changeBinding: 0 ] } .		{ #label2 . [ #n changeBinding: (#n binding + 1) ] } .		{ #label3 . [ #n changeBinding: (#n binding + 1) ] } .		{ #label4 . [ #n changeBinding: (#n binding + 1) ] } .		{ #label5 . [ #n changeBinding: (#n binding + 1) ] } .		{ #label6 . [ #n changeBinding: (#n binding + 1) ] } .		{ #label7 . [ #RETURN binding value: #n binding  ] } .	}.	self assert: result == 5.! !!PROGTest methodsFor: 'default' stamp: 'AlexisRico 1/18/2019 23:39'!testCaseBase2	| result |	result := PROG withInit: {{ #n . 10 } . { #coll . OrderedCollection new }}  do: {		{ #label1 . [ #n binding == 0 ifTrue: [ #RETURN binding value: #coll binding ]  ] } .		{ #label2 . [ #coll changeBinding: ((#coll binding) add: #n binding; yourself) ] } .		{ #label3 . [ #n changeBinding: (#n binding - 1) ] } .		{ #label4 . [ #label1 binding value ] }	}.	self assert: (result includesAll: #(10 9 8 7 6 5 4 3 2 1)).! !'From Pharo3.0 of 18 March 2013 [Latest update: #30864] on 20 January 2019 at 11:39:56.555249 pm'!!Symbol methodsFor: '*PracticaCAP' stamp: 'AlexisRico 1/16/2019 14:39'!changeBinding: newValue	| context |	context := thisContext.	[ context = nil ] whileFalse:		[   ((context receiver isMemberOf: Binding)				and: [ context selector = #of:to:in:					and: [context receiver key = self]])				"Store new binding value and return"				ifTrue: [^ context receiver value: newValue]				ifFalse: [context := context sender]		].	self error: 'No binding for ', self asString.! !